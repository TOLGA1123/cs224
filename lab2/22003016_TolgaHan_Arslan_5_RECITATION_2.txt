CS224
Recitation 2
Section 5
Tolga Han Arslan
22003061
13.03.2023

.text
	li $v0, 4
	la $a0, message1
	syscall
	li $v0, 5
	syscall
	move $a0, $v0 
	jal CreateArray		#call CreateArray with the given array size $a0
	move $a1, $v0		#store array's size in $a1		for first array
	move $a2, $v1		#store the address of array in $a2
	move $s4, $a1		#$s4 = first array's size	
	move $s5, $a2		#$s5 = first array's address		#$s4-$s5-$s6-$s7 used for storing 2 arrays size and address that will later be copied on arguments
	li $v0, 4
	la $a0, message1
	syscall
	li $v0, 5
	syscall
	move $a0, $v0
	jal CreateArray
	move $a3, $v0		#copy second array's size to $a3  since $v0 is changed during PrintArray
	la $a0, message3
	li $v0, 4
	syscall		
	jal PrintArray
	move $a1, $a3		#store array's size in $a1		for second array
	move $a2, $v1		#store the address of array in $a2
	move $s6, $a1		#$s6 = second array's size	
	move $s7, $a2		#$s7 = second array's address   
	la $a0, message4
	li $v0, 4
	syscall		
	jal PrintArray
	#arguments for CalculateDistance
	move $a0, $s4		#$a0 = first array's size
	move $a1, $s5		#$a1 = first array's address
	move $a2, $s6		#$a2 = second array's size
	move $a3, $s7		#$a3 = second array's address
	jal CalculateDistance
	move $a1, $v0		#copy the distance to $a1
	la $a0, message6
	li $v0, 4
	syscall
	move $a0, $a1
	li $v0, 1
	syscall
	li $v0, 10		#exit the program
	syscall
	
	
#subprogram that creates an array with given size  #$a0 = array size (bytes)
CreateArray:
	addi $sp, $sp, -12
	sw $s0, 0($sp)		#save $s0 on stack  ($s0 = 0)
	sw $s1, 4($sp)		#save $s1 on stack ($s1 = 0)
	sw $ra, 8($sp)		#save $ra
	move $s0, $a0		#array size = $s0
	sll $a0, $a0, 2		#array size integer to byte
	li $v0, 9
	syscall			#allocate memory
	move $s1,$v0		#s1 = array pointer (address of the array)
	jal InitializeArray
	move $v0, $s0		#return the array size
	move $v1, $s1		#return the base address of the array
	lw $ra, 8($sp)		#restore $ra
	lw $s1, 4($sp)		#restore $s1
	lw $s0, 0($sp)		#restore $s0
	addi $sp, $sp, 12	#deallocate stack space
	jr $ra
	

#subprogram that initializes the array values with user inputs
InitializeArray:
	addi $sp, $sp, -8
	sw $s2, 0($sp)		#save $s2 on stack ($s2 = 0)	#s2 = array index i
	sw $s1, 4($sp)		#save $s1 on stack (array pointer = address of the array)
for:
	beq $s2, $s0, done
	li $v0, 4
	la $a0, message2
	syscall
	li $v0, 5
	syscall
	sw $v0, 0($s1)		#filling the array with inputs
	addi $s2, $s2, 1	#i = i+1
	addi $s1, $s1, 4	#incrementing array pointer by 4
	j for
done:
	lw $s2, 0($sp)		#restore $s2 from stack
	lw $s1, 4($sp)		#restore $s1 from stack
	addi $sp, $sp, 8	#deallocate stack space
	jr $ra

#subprogram that prints array elements			#$a1: array size,	$a2: array address 
PrintArray:
	addi $sp, $sp, -8
	sw $s0, 0($sp)			#save $s0 in stack ($s0 = 0)
	sw $s1, 4($sp)			#save $s1 in stack ($s1 = 0)			
	addi $s0, $s0, 0		#$s0 = array index i
	move $s1, $a2			#$s1 = array pointer
printFor:
	beq $s0, $a1, printDone
	li $v0, 1
	lw $a0, 0($s1)
	syscall
	addi $s0, $s0, 1		# i = i + 1
	addi $s1, $s1, 4		# increment pointer by 4
	li $v0, 4
	la $a0, message5
	syscall
	j printFor
printDone:
	lw $s0, 0($sp)			# restore $s0
	lw $s1, 4($sp)			# restore $s1
	addi $sp, $sp, 8		#deallocate stack space
	jr $ra
	
	
#subprogram that calculates the Hamming distance between two arrays		#assuming that two arrays have same size
#$a0 = first array's size
#$a1 = first array's address
#$a2 = second array's size
#$a3 = second array's address
#returns hamming distance in $v0
CalculateDistance:
	addi $sp, $sp, -12
	sw $s0, 0($sp)			#save $s0 in stack
	sw $s1, 4($sp)			#save $s1 in stack
	sw $s2, 8($sp)			#save $s2 in stack
	addi $s0, $0, 0			#$s0 = array index i	i + 1
	li $v0, 0			#$v0 = Distance (Return Value)
	
	
	###### Simplify here a bit
Iterate:
	beq $s0, $a0, Return
	lw $s1, 0($a1)			#$s1 = array1(i)	$a1 + 4
	lw $s2, 0($a3)			#$s2 = array2(i)	$a3 + 4
	bne $s1, $s2, AddDistance 			#if array1(i) != array2(i)
done5:
 	addi $s0, $s0, 1
 	addi $a1, $a1, 4
 	addi $a3, $a3, 4
	j Iterate
AddDistance: 
	addi $v0, $v0, 1		#if array1(i) != array2(i) increment distance
	j done5
Return:	
	lw $s0, 0($sp)
	lw $s1, 4($sp)
	lw $s2, 8($sp)
	addi $sp, $sp, 12
	jr $ra
.data
	message1: .asciiz "Enter the size of array: "
	message2: .asciiz "Enter the elements of array: "
	message3: .asciiz "\n First array = "
	message4: .asciiz "\n Second array = "
	message5: .asciiz " "
	message6: .asciiz "\n Hamming distance between two arrays: "
	
	
	
.text
Continue:
	bne $a3, $0, Stop	#input = 1 branch to stop
	
	jal GetValues		#$v0 = first value, $v1 = second value
	move $a1, $v0		#first register $a1	decimal
	move $a2, $v1		#second register $a2	decimal
	jal DisplayRegisters
	jal FindDistance
	move $a3, $v0		#copy hamming distance to $a3
	la $a0, message5
	li $v0, 4
	syscall
	li $v0,1 
	move $a0, $a3
	syscall
	
	la $a0, message0
	li $v0, 4
	syscall
	li $v0, 5
	syscall
	move $a3, $v0
	j Continue
Stop:
	li $v0, 10		#exit
	syscall
#Subprogram that get values to be assigned to the registers from the user
GetValues:
	addi $sp, $sp, -8
	sw $s0, 0($sp)		#store $s0
	sw $s1, 4($sp)		#store $s1
	la $a0, message1
	li $v0, 4
	syscall
	li $v0, 5
	syscall
	move $s0, $v0		#copy first value to $s0
	la $a0, message2
	li $v0, 4
	syscall
	li $v0, 5
	syscall
	move $s1, $v0		#copy second value to $s1
	move $v0, $s0		#return first value in $v0
	move $v1, $s1		#return second value in $v1
	lw $s1, 4($sp)		#restore $s1
	lw $s0, 0($sp)		#restore $s0
	addi $sp, $sp, 8	#deallocate stack space
	jr $ra
#Subprogram that displays register values in hex	#syscall 34
DisplayRegisters:
	la $a0, message3
	li $v0, 4
	syscall
	li $v0, 34		#34 = hex form, 35= binary form
	move $a0, $a1		#first value to print
	syscall
	la $a0, message4
	li $v0, 4
	syscall
	li $v0, 34		#34 = hex form, 35= binary form
	move $a0, $a2		#second value to print
	syscall
	jr $ra
	
#Subprogram that finds the Hamming Distance between two registers	assuming binary form to calculate differences idk?
FindDistance:
	addi $sp, $sp, -20
	sw, $s0, 0($sp)		#save $s0
	sw $s1, 4($sp)		#save $s1
	sw $s2, 8($sp)		#save $s2
	sw $s3, 12($sp)		#save $s3
	sw $s4, 16($sp)		#save $s4	
	addi $s0, $s0, 0	#$s0 = distance
	move $s1, $a1		#$s1 = first value
	move $s2, $a2		#$s2 = second value
	xor $s3, $s1, $s2	#$s3 = first value xor second value (x)
while: 				#hamming distance with integers algorithm
	ble $s3, $0, done
	andi $s4, $s3, 1	#$s4 = x & 1
	add $s0, $s0, $s4	#add distance
	srl $s3, $s3, 1		#x = >>1
	j while
done:	
	move $v0, $s0		#return distance in $v0
	lw $s0, 0($sp)		#restore $s0
	lw $s1, 4($sp)		#restore $s1
	lw $s2, 8($sp)		#restore $s2
	lw $s3, 12($sp)		#restore $s3
	lw $s4, 16($sp)		#restore $s4
	addi $sp, $sp, 20	#deallocate space
	jr $ra

.data
message0: .asciiz "\n Enter 0 to continue, Enter 1 to stop: "
message1: .asciiz "\n Enter a value to register1: "
message2: .asciiz "\n Enter a value to register2: "
message3: .asciiz "\n Register1 value in hex: "
message4: .asciiz "\n Register2 value in hex: "
message5: .asciiz "\n Hamming distance between two registers: "

.text
	li $v0, 4
	la $a0, message1
	syscall
	li $v0, 5
	syscall
	move $a0, $v0 
	jal CreateArray
	move $a1, $v0		#store array's size in $a1		
	move $a2, $v1		#store the address of array in $a2
	la $a0, message3
	li $v0, 4
	syscall
	jal PrintArray
	la $a0, message5
	li $v0, 4
	syscall
	li $v0, 5
	syscall
	move $a0, $v0		#store n in $a0
	jal ArrayEntryCheck
	move $a3, $v0		#store appearance in $a3
	la $a0, message6
	li $v0, 4
	syscall
	li $v0, 1
	move $a0, $a3
	syscall
	

	li $v0, 10		#exit
	syscall 		



#subprogram that creates an array with given size  #$a0 = array size (bytes)	#$v0 = array size #$v1 = array address
CreateArray:
	addi $sp, $sp, -12
	sw $s0, 0($sp)		#save $s0 on stack  ($s0 = 0)
	sw $s1, 4($sp)		#save $s1 on stack ($s1 = 0)
	sw $ra, 8($sp)		#save $ra
	move $s0, $a0		#array size = $s0
	sll $a0, $a0, 2		#array size integer to byte
	li $v0, 9
	syscall			#allocate memory
	move $s1,$v0		#s1 = array pointer (address of the array)
	jal InitializeArray
	move $v0, $s0		#return the array size in $v0
	move $v1, $s1		#return the base address of the array iv $v1
	lw $ra, 8($sp)		#restore $ra
	lw $s1, 4($sp)		#restore $s1
	lw $s0, 0($sp)		#restore $s0
	addi $sp, $sp, 12	#deallocate stack space
	jr $ra
#subprogram that initializes the array values with user inputs
InitializeArray:
	addi $sp, $sp, -8
	sw $s2, 0($sp)		#save $s2 on stack ($s2 = 0)	#s2 = array index i
	sw $s1, 4($sp)		#save $s1 on stack (array pointer = address of the array)
for:
	beq $s2, $s0, done
	li $v0, 4
	la $a0, message2
	syscall
	li $v0, 5
	syscall
	sw $v0, 0($s1)		#filling the array with inputs
	addi $s2, $s2, 1	#i = i+1
	addi $s1, $s1, 4	#incrementing array pointer by 4
	j for
done:
	lw $s2, 0($sp)		#restore $s2 from stack
	lw $s1, 4($sp)		#restore $s1 from stack
	addi $sp, $sp, 8	#deallocate stack space
	jr $ra
	
#subprogram that prints array elements			#$a1: array size,	$a2: array address 
PrintArray:
	addi $sp, $sp, -8
	sw $s0, 0($sp)			#save $s0 in stack ($s0 = 0)
	sw $s1, 4($sp)			#save $s1 in stack ($s1 = 0)			
	addi $s0, $s0, 0		#$s0 = array index i
	move $s1, $a2			#$s1 = array pointer
printFor:
	beq $s0, $a1, printDone
	li $v0, 1
	lw $a0, 0($s1)
	syscall
	addi $s0, $s0, 1		# i = i + 1
	addi $s1, $s1, 4		# increment pointer by 4
	li $v0, 4
	la $a0, message4
	syscall
	j printFor
printDone:
	lw $s0, 0($sp)			# restore $s0
	lw $s1, 4($sp)			# restore $s1
	addi $sp, $sp, 8		#deallocate stack space
	jr $ra
	
#subprogram that receives an array and an index position of the array and returns the number of occurrences of the array element that occurs at that position
# $a0: n (index position)  # $a1: array size  # $a2: array address		index n starts at 0
ArrayEntryCheck:		
	addi $sp, $sp, -28
	sw $s0, 0($sp)		#store $s0
	sw $s1, 4($sp)		#store $s1
	sw $s2, 8($sp)		#store $s2
	sw $s3, 12($sp)		#store $s3
	sw $s4, 16($sp)		#store $s4
	sw $s5, 20($sp)		#store $s5
	sw $s6, 24($sp)		#store $s6
	move $s0, $a0		#$s0 = index n
	move $s1, $a1		#$s1 = array size
	move $s2, $a2		#$s2 = array address (pointer)
	sll $s0, $s0, 2		#multiply n by 4 
	add $s2, $s2, $s0	#array pointer now points to the given index
	lw $s3, 0($s2)		#save n'th element to $s3	n=0 0x4 = 0 first element
	sub $s2, $s2, $s0	#return back array pointer to first index
	addi $s4, $0, 0		#$s4 = i	
	addi $s5, $0, 0		#$s5 = appearance count
for2:
	beq $s4, $s1, done2	#if i = arraysize branch to done2
	lw $s6, 0($s2)		#$s6 = array(i)		# $s4 increment 1 # $s2 increment 4
	beq $s6, $s3, same
	addi $s4, $s4, 1	#increment i by 1
	addi $s2, $s2, 4	#increment pointer by 4
	j for2
	same:
	addi $s5, $s5, 1	#increment appearance by 1
	addi $s4, $s4, 1	#increment i by 1
	addi $s2, $s2, 4	#increment pointer by 4
	j for2
done2:	
	move $v0, $s5		#return appearance count on $v0
	lw $s0, 0($sp)		#restore $s0
	lw $s1, 4($sp)		#restore $s1
	lw $s2, 8($sp)		#restore $s2
	lw $s3, 12($sp)		#restore $s3
	lw $s4, 16($sp)		#restore $s4
	lw $s5, 20($sp)		#restore $s5
	lw $s6, 24($sp)		#restore $s6
	addi $sp, $sp, 28	#deallocate stack space
	jr $ra
	
.data
	message1: .asciiz "Enter the size of array: "
	message2: .asciiz "Enter the elements of array: "	
	message3: .asciiz "\n Array: "
	message4: .asciiz " " 
	message5: .asciiz "\n Enter index position n: "
	message6: .asciiz "\n The number of occurrences of the array element that occurs at n'th position: "
