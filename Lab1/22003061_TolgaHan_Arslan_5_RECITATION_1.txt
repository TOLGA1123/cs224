CS224		vivado mars
Lab 1
Section 5
Tolga Han Arslan
22003061
27.02.2023

	.text
# $t0: array pointer
# $t1: array element i
# $t2: array size    max 20
	la $t0, array			# $t0: pointing to the beginning address of the array
	addi $t1, $0, 0  		#i=0
	
	li $v0, 4
	la $a0, message1		# asking user for arraysize
	syscall
	li $v0, 5
	syscall
	move $t2, $v0			# copying array size to $t2
	
for:
	beq $t1, $t2, done		# if i == arraysize branch to done
	li $v0, 4
	la $a0, message2
	syscall
	li $v0, 5
	syscall
	sw $v0, ($t0)       		# filling the array
	addi $t1, $t1, 1         	# i=i+1
	addi $t0, $t0, 4		# increment $t0 by 4
	j for
done:
	li $v0, 4
	la $a0, message3
	syscall
	li $v0, 5
	syscall
	addi $s0, $v0, 0		# store input N to $s0   
	
	la $t0, array			# $t0: pointing to the beginning of the array
	li $t1, 0
	addi $t3, $0, 0  		#$t3: number of array members equal to N
	addi $t4, $0, 0  		#$t4: number of array members less than N
	addi $t5, $0, 0  		#$t5: number of array members greater than N
	addi $t6, $0, 0  		#$t6: number of array members evenly divisible by N
loop:	
	lw $a0, 0($t0) 			# $a0 = array[i]
	beq $t1, $t2, exitloop  	# if i == arraysize exit loop
	bne $a0, $s0, notequal		# if array[i] != N branch
	addi $t3, $t3,1
	notequal:
	bgeu $a0, $s0, notless		# if array[i] >= N branch
	addi $t4, $t4, 1
	notless:
	bleu $a0, $s0, notgreater	# if array[i] <= N branch
	addi $t5, $t5, 1
	notgreater:
	div $a0, $s0			# division array[i]/N   remainder goes to $hi
	mfhi $s1			#copy remainder to $s1 register
	bne $s1, $0, notdivisible	# if remainder == 0 it is divisible
	addi $t6, $t6,1
	notdivisible:
	addi $t1, $t1, 1		#increment array index i
	addi $t0, $t0, 4		#increment array pointer by 4
	j loop
	
exitloop:  
	#print number of elements equal to N
	 li $v0, 4
	 la $a0, message4
	 syscall
	 move $a0, $t3
	 li $v0, 1
	 syscall
	 #print number of elements less than N
	 li $v0, 4
	 la $a0, message5
	 syscall
	 li $v0, 1
	 move $a0, $t4
	 syscall
	 #print number of elements greater than N
	 li $v0, 4
	 la $a0, message6
	 syscall
	 li $v0, 1
	 move $a0, $t5
	 syscall
	 #print number of elements evenly divisible by N
	 li $v0, 4
	 la $a0, message7
	 syscall
	 li $v0, 1
	 move $a0, $t6
	 syscall
	 li $v0, 10 	#exit
	 syscall
	 
	

.data
	array: .space 80 	# Allocate 80 bytes = space enough to hold 20 words
	message1: .asciiz "Enter the number of elements: "
	message2: .asciiz "Enter integers: "
	message3: .asciiz "Enter N: "
	message4: .asciiz "\n Number of elements equal to N: "
	message5: .asciiz "\n Number of elements less than N: "
	message6: .asciiz "\n Number of elements greater than N: "
	message7: .asciiz "\n Number of elements evenly divisible by N: "

##
## Program1.asm - prints out "hello world"
##
##	a0 - points to the string
##

#################################
#					 	#
#		text segment		#
#						#
#################################

	.text		
	.globl __start 

__start:		# execution starts here
	la $a0,str	# put string address into a0
	li $v0,4	# system call to print
	syscall		#   out a string

	li $v0,10  # system call to exit
	syscall	#    bye bye


#################################
#					 	#
#     	 data segment		#
#						#
#################################

	.data
str:	.asciiz "HELLO Navid \n"
n:	.word	10

##
## end of file Program1.asm

##
## Program2.asm asks user for temperature in Celsius,
##  converts to Fahrenheit, prints the result.
##
##	v0 - reads in Celsius
##	t0 - holds Fahrenheit result
##	a0 - points to output strings
##     F7 Run 1 step a time

#################################
#					 	#
#		text segment		#
#						#
#################################

	.text		
	.globl __start	

__start:
	la $a0,prompt	# output prompt message on terminal
	li $v0,4	# syscall 4 prints the string
	syscall

	li $v0, 5	# syscall 5 reads an integer    $v0 ---> v0   li $v0        $v0 holds input
	syscall

	mul $t0,$v0,9	# to convert,multiply by 9,	$t0 is 0 initially 0x9=0
	div $t0,$t0,5	# divide by 5, then
	add $t0,$t0,32	# add 32

	la $a0,ans1	# print string before result
	li $v0,4
	syscall

	move $a0,$t0	# print integer result
	li $v0,1		# using syscall 1
	syscall

	la $a0,endl	# system call to print
	li $v0,4		# out a newline
	syscall

	li $v0,10		# system call to exit
	syscall		#    bye bye


#################################
#					 	#
#     	 data segment		#
#						#
#################################

	.data
prompt:	.asciiz "Enter temperature (Celsius): "
ans1:	.asciiz "The temperature in Fahrenheit is "
endl:	.asciiz "\n"

##
## end of file Program2.asm

##
##	Program3.asm is a loop implementation
##	of the Fibonacci function
##        

#################################
#					 	#
#		text segment		#
#						#
#################################

	.text		
.globl __start
 
__start:		# execution starts here
	li $a0,7	# to calculate fib(7)
	jal fib		# call fib			#flb typo
	move $a0,$v0	# print result
	li $v0, 1
	syscall					#syscal typo

	la $a0,end	# print newline
	li $v0,4
	syscall

	li $v0,10	#should be 10 not 100
	syscall		# bye bye

#------------------------------------------------


fib:	move $v0,$a0	# initialise last element
	blt $a0,2,done	# fib(0)=0, fib(1)=1			#don

	li $t0,0	# second last element
	li $v0,1	# last element

loop:	add $t1,$t0,$v0	# get next value	#v0
	move $t0,$v0	# update second last
	move $v0,$t1	# update last element
	sub $a0,$a0,1	# decrement count
	bgt $a0,1,loop	# exit loop when count=0             # 0 should be 1 here  one extra addition
done:	jr $ra

#################################				Go: execution paused at breakpoint: Program3.asm
#					 	#
#     	 data segment		#
#						#
#################################

	.data
end:	.asciiz "\n"		#end1

##
## end of Program3.asm

.text
	li $v0, 4
	la $a0, message1
	syscall
	li $v0, 5
	syscall
	move $t0, $v0 		#save a to $t0
	li $v0, 4
	la $a0, message2
	syscall
	li $v0, 5
	syscall
	move $t1, $v0		#save b to $t1
	sll $t2, $t0, 1		#$t2 = 2*a
	addi $t3, $t3, 8	#$t3 = 8
	addi $t4, $t4,7
	sub $t4, $t4, $t1	#$t4 = 7-b
	div $t3, $t2		#division
	mflo $s0		#$s0 = 8/2*a
	add $s0, $s0, $t4	#$s0 = (8/2*a) +7-b
	li $v0, 4
	la $a0, message3
	syscall	
	move $a0, $s0		#copy x to $a0 to be printed
	li $v0, 1
	syscall

	li $v0, 10
	syscall 		#exit the program
.data
message1: .asciiz "\n Enter a: "
message2: .asciiz "\n Enter b: "
message3: .asciiz "\n Result of the expression(8/(2*a)) + 7-b  = "	#4/a here 